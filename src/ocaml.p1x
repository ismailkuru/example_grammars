open P1_lib

let c = content

let ident = parse_RE "[a-z][A-Za-z0-9]*"

let keywords = ["let";"in";"if";"then";"else";"rec";"match";"with"]

let ident x = 
  x |> ident 
  |> List.filter (fun (x,_) -> not (List.mem (c x) keywords))

let _Ident = parse_RE "[A-Z][A-Za-z0-9]*"

let reserved_Idents = ["List";"String";"Hashtbl"]

let constr x = x |> _Ident |> List.filter (fun (x,_) -> not (List.mem (c x) reserved_Idents))

(* FIXME this is now in P1 *)
let ss_concat_2 (`SS(s,i,j)) (`SS(s,k,l)) = 
  assert (j=k);
  (`SS(s,i,l))

let rec ss_concat xs = (match xs with
    | [] -> failwith "ss_concat"
    | [x] -> x
    | x::xs -> ss_concat_2 x (ss_concat xs))

let comment = ((a "(*") **> (until_a "*)") **> (a "*)")) >> (fun (x,(y,z)) -> ss_concat [x;y;z])
let ws = (parse_RE "[ \n]*")
let ws = ws ||| ((ws **> comment **> ws) >> (fun (x,(y,z)) -> ss_concat [x;y;z]))
let w = ws

let num = parse_RE "[0-9]+"
let notdquote = until_a "\""
let notsquote = until_a "'"

module Map = struct
  let texify_underscore s = (Str.global_replace (Str.regexp "[_]") "\\_" s) 

  let valuename s = (
    let f1 s = (
    "\\textit{"
    ^(texify_underscore s)
    ^"}")
    in 
    let s = (match s with
        (* replace these with any ad-hoc transformations of valuenames you need *)
      | "ss4" -> "ss" 
      | "lc4" -> "lc"
      | "oracle4" -> "oracle"
      | "rules7" -> "rules"
      | "tmparsers7" -> "tmparsers"
      | _ -> s)
    in
  f1 s)

  let module_name s = "\\textsf{"^s^"}"
  
  let module_path s = "\\textsf{"^s^"}"
  
  let constr s = "\\textsf{"^(texify_underscore s)^"}"
  
  let _type s = s
  
  let ident s = s

  (* convert a string to latex whitespace *)
  let rec to_whitespace s = (
   if s = "" then "" else
   let c = s.[0] in
   if c=' ' then "\\ "^(to_whitespace (String.sub s 1 (String.length s - 1))) else
   "\\\\\n"^(to_whitespace (String.sub s 1 (String.length s - 1))))
                                     
  let w s = to_whitespace(content s)

  let _CONSTRNAME s = "\\textsf{" ^(texify_underscore s) ^"}"
 
  let _TYPECONSTRNAME s = ("\\textsf{"^(texify_underscore s)^"}")

  let tyvar s = 
    if s = "'a" then "\\alpha" else 
    if s = "'b" then "\\beta" else 
    if s = "'c" then "\\gamma" else 
    if s = "'d" then "\\delta" else 
    if s = "'e" then "\\epsilon" else 
    if s = "'f" then "\\zeta" else 
    "\\textit{"
    ^(texify_underscore s)
    ^"}"

end (* Map *)

<<g<<

S -> VALUENAME {{ x1 }}

(* 6.3 Names *)                       

VALUENAME -> ?ident?                   {{ Map.valuename(c x1) }}                                       
                                      
INFIXOP -> "="                         {{ c x1 }}                                              
  | "++"                               {{ c x1 }}                                                
  | "::"                               {{ c x1 (* FIXME not an infix ?*) }}                      
  | "<"                                {{ c x1 }}                                                      
  | "<="                               {{ "{\\le}" }}                                                  

  | "+"                                {{ c x1 (* FIXME not an infix ?*) }}                      
  | "@"                                {{ "++" (* FIXME not an infix ?*) }}                           
  | "&&"                               {{ "{\\&\\&}" }}                                               
  | "||"                               {{ c x1 }}                                               
  | "***>"                             {{ "{\\otimes}" }}                                                 
  | "||||"                             {{ "{\\oplus}" }}                                                  
  | ">>>>"                             {{ "{\\gg}" }}                                          
  | ">>="                              {{ "{{\\gg}\\!\\!=}" }}                                    
  | "|||"                              {{ c x1 }}                                                     

FIELDNAME -> ?ident?                   {{ Map.valuename(c x1) }}                                                      
                                     

VALUEPATH -> VALUENAME       {{ x1 }}                          
  | MODULEPATH "." VALUENAME {{ x1^"."^x3 }}

(* this was ?Ident? but we don't want List.map interpreted as CONSTR.FIELDNAME *)
CONSTR ->                 
    ?constr?               {{ Map.constr (c x1) }}                           
                          
MODULEPATH -> ?_Ident?      {{ Map.module_path (c x1) }}                      
  | MODULEPATH "." ?_Ident? {{ x1^"."^(Map.module_path (c x3)) }}



(* 6.4 Type expressions; following for type defns FIXME needs tidying up  *)

TYPEXPR -> "'" ?ident?            {{ Map.tyvar ([x1;x2]|>ss_concat|>c) }}                                                                    
  | "(" w1=?w? t=TYPEXPR w2=?w? ")"       {{ "("^(Map.w w1)^t^(Map.w w2)^")" }}                                                  
  | t1=TYPEXPR w1=?w? "->" w2=?w? t2=TYPEXPR  {{ t1^(Map.w w1)^"{\\rightarrow}"^(Map.w w2)^t2 }}                                               
  | s1=TYPEXPR w1=?w? "*" w2=?w? s2=TYPEXPR   {{ s1^(Map.w w1)^"{\\times}"^(Map.w w2)^s2 }} (* FIXME ambiguity *)                          
  | TYPECONSTR                    {{ x1 }}                                                                                                  
  | s2=TYPECONSTR w1=?w? s1=TYPEXPRA       {{ Map._type (s2^(Map.w w1)^s1) }}

TYPEXPRA -> TYPEXPR {{ x1 }}
  | TYPEXPR ?w? TYPEXPRA          {{ x1^(Map.w x2)^x3 }}

OCAMLTYPEXPR -> "'" ?ident?            {{ Map.tyvar ([x1;x2]|>ss_concat|>c) }}                                                                    
  | "(" w1=?w? t=TYPEXPR w2=?w? ")"       {{ "("^(Map.w w1)^t^(Map.w w2)^")" }}                                                  
  | t1=TYPEXPR w1=?w? "->" w2=?w? t2=TYPEXPR  {{ t1^(Map.w w1)^"{\\rightarrow}"^(Map.w w2)^t2 }}                                               
  | s1=TYPEXPR w1=?w? "*" w2=?w? s2=TYPEXPR   {{ s1^(Map.w w1)^"{\\times}"^(Map.w w2)^s2 }} (* FIXME ambiguity *)                          
  | TYPECONSTR                    {{ x1 }}                                                                                                  
  | s1=TYPEXPR w1=?w? s2=TYPECONSTR        {{ Map._type (s1^(Map.w w1)^s2) (* FIXME try and map types at a higher level as well *)  }}
  | "(" w1=?w? s1=TYPEXPRA w2=?w? ")" w3=?w? s2=TYPECONSTR {{ "("^(Map.w w1)^s1^(Map.w w2)^")"^(Map.w w3)^s2 }}

OCAMLTYPEXPRA -> TYPEXPR {{ x1 }}
  | TYPEXPR ?w? "," ?w? TYPEXPRA {{ x1^(Map.w x2)^","^(Map.w x4)^x5 }}
                                  
(*                                
  | "(" ?w? TYPE ?w? ")"          {{ fun (b1,(w1,(s1,(w2,b2)))) -> ccat [b1;w1;s1;w2;b2] }}                                                
  | TYPE ?w? ?ident?              {{ fun (t,(_,i)) -> t^" "^(map_type (content i)) }}                                                       
  | MODULEPATH "." TYPEXPR        {{ fun (s1,(_,s2)) -> map_type (s1^"."^s2) }}                                                             
  | TYPEXPR ?w? TYPECONSTR        {{ fun (s1,(w1,s2)) -> s1^(w w1)^s2 }}                                                                    
*)                                
                                  
TYPECONSTR -> TYPECONSTRNAME      {{ x1  }}                                                                                                 
  | MODULEPATH "." TYPECONSTRNAME {{ Map._type(x1^"."^x3) }}                                                              
                                  
POLYTYPEXPR -> TYPEXPR            {{ (* FIXME *) x1 }}                                                                                      




(* 6.5 Constants *)

CONSTANT -> CONSTR      {{ x1 }}                                          
  | "[" ?w? "]"         {{ "["^(Map.w x2)^"]" }}            
  | ?num?               {{ c x1 }}                                           
  | "-" ?num?           {{ (c x1)^(c x2) }}                
  | '"' s=?notdquote? '"' {{ ("{\\texttt{\"" ^ (c s) ^ "\"} }") }}
  | "'" s=?notsquote? "'" {{ ("'"^(c s)^"'") }}            
  | "()"                {{ c x1 }}                                           



(* 6.6 Patterns *)

PATTERN -> EXPR {{ x1 }} 

(* 6.7 Expressions ; grammar is too ambiguous so we identify atomic expressions which can be arguments to functions *)
                                                       
EXPR -> ATEXPR                                            {{ x1 }}                                                                                                                         
  | e=EXPR ":" t=TYPEXPR                                  {{ e^":"^t }}                                                                                                   
  | EXPR ?w? "," ?w? EXPRA                                {{ x1^(Map.w x2)^(c x3)^(Map.w x4)^x5 }}                                                                                                                     
  | CONSTR ?w? EXPR                                       {{ x1^(Map.w x2)^x3 }}                                                                                           
  | EXPR ?w? "::" ?w? EXPR                                {{ x1^(Map.w x2)^(c x3)^(Map.w x4)^x5 }}                                                                                                                    
  | FNARGS                                                {{ x1  }}                                                                                                              
  | EXPR ?w? INFIXOP ?w? EXPR                             {{ x1^(Map.w x2)^(x3)^(Map.w x4)^x5 }}                                                                         
  | "if" w1=?w? e1=EXPR w2=?w? "then" w3=?w? e2=EXPR w4=?w? "else" w5=?w? e3=EXPR 
    {{ ("\\textsf{if}"^(Map.w w1)^e1^(Map.w w2)^"\\textsf{then}"^(Map.w w3)^e2^(Map.w w4)^"\\textsf{else}"^(Map.w w5)^e3) }}
  | "match" w1=?w? e=EXPR w2=?w? "with" w3=?w? cs=PATTERNMATCHING w4=?w? "end"   
    {{ ("\\textsf{match}"^(Map.w w1)^e^(Map.w w2)^"\\textsf{with}"^(Map.w w3)^((*String.concat "||"*) cs)^(Map.w w4)^("\\textsf{end}")) }}            
  | "let" w1=?w? e1=LETBINDING w2=?w? "in" w3=?w? e2=EXPR 
    {{ "\\textsf{let}"^(Map.w w1)^e1^(Map.w w2)^"\\textsf{in}"^(Map.w w3)^e2 }}                                                
  | "let" w0=?w? "rec" w1=?w? e1=LETBINDING w2=?w? "in" w3=?w? e2=EXPR
    {{ "\\textsf{let}"^(Map.w w0)^"rec"^(Map.w w1)^e1^(Map.w w2)^"\\textsf{in}"^(Map.w w3)^e2 }}                                                
  | "fun" w1=?w? e1=MULTIPLEMATCHING                            
    {{ "\\textsf{fun}"^(Map.w w1)^e1 }}                                                                                         
(* FIXME List.map parses as ATEXPR "." FIELDNAME, where ATEXPR is CONSTANT CONSTR *)

ATEXPR ->                    
    VALUEPATH                 {{ x1 }}                                                             
  | CONSTANT                  {{ x1 }}                                                             
  | "(" w1=?w? e1=EXPR w2=?w? ")" {{ "("^(Map.w w1)^e1^(Map.w w2)^")" }}           
  | "[" w1=?w? ss=EXPRLIST w2=?w? "]"  {{  "["^(Map.w w1)^ss^(Map.w w2)^"]" }}           
  | RECORD                    {{ x1 }}                                                     
  | s1=ATEXPR "." s2=FIELDNAME      {{  s1^"."^s2 (* FIXME rec select *)  }}           
  | s1=ATEXPR "." "[" s2=EXPR "]"   {{  s1^".["^s2^"]"  }}                     
  | "_"                       {{ "\\_" }} (* FIXME this just because PATTERNs are EXPRs *)
  | "<fun>"                   {{ "<\\textit{fun}>" (* "{<{\\textit{fun}>}" *) }} (* for return values from ocaml toplevel *)
  | "(" w1=?w? s1=INFIXOP w2=?w? ")"  {{ "("^(Map.w w1)^s1^(Map.w w2)^")" }}
                             
EXPRA -> EXPR                 {{ x1 }}                                                             
  | EXPR ?w? "," ?w? EXPRA    {{ x1^(Map.w x2)^(c x3)^(Map.w x4)^x5 }}                                                         

EXPRLIST ->                  
    EXPR                      {{ x1 }}                                                             
  | EXPR ?w? ";" ?w? EXPRLIST {{ x1^(Map.w x2)^(c x3)^(Map.w x4)^x5 }}                                                         
                             

PATTERNMATCHING -> CASESB     {{ x1 }}                                                      
  | "|" w1=?w? x=CASESB       {{ "|"^(Map.w w1)^x (* initial | *) }}                 
                             
CASESB ->                    
  CASE                        {{ x1 }}                                                     
  | c1=CASE w1=?w? "|" w2=?w? cs=CASESB   {{ c1^(Map.w w1)^"|"^(Map.w w2)^cs }}           
(* above clause erroneously allows cases to start with a bar *)
                                                               
CASE -> e1=PATTERN w1=?w? "->" w2=?w? e2=EXPR                {{ e1^(Map.w w1)^"{\\rightarrow}"^(Map.w w2)^e2^"" }}                                                  
                                                
MULTIPLEMATCHING -> PATTERNMATCHING              {{ x1 }} (* FIXME *)                                                                                                           

LETBINDING -> PATTERN ?w? "=" ?w? EXPR           {{ x1^(Map.w x2)^(c x3)^(Map.w x4)^x5 }}                                                                                                                   


                                                
FNARGS -> ATEXPR ?w? ATEXPR                      {{ x1^(Map.w x2)^x3 }}                                                                                         
  | ATEXPR ?w? FNARGS                            {{ x1^(Map.w x2)^x3 }}                                                                                         
                                                
RECORD ->                                       
    "<|" w1=?w? fs=FIELDS w2=?w? "|>"                       {{ "\\langle{}"^(Map.w w1)^(fs)^(Map.w w2)^"\\rangle{}" }}                                                 
  | "<|" w1=?w? i=ATEXPR w2=?w? "with" w3=?w? fs=FIELDS w4=?w? "|>" {{ "\\langle{}"^(Map.w w1)^i^(Map.w w2)^"\\textsf{with}"^(Map.w w3)^fs^(Map.w w4)^"\\rangle{}" }}
                                                
FIELDS ->                                       
    FIELD                                        {{ x1 }}                                                                                                                       
  | FIELD ?w? ";" ?w? FIELDS                     {{ x1^(Map.w x2)^(c x3)^(Map.w x4)^x5 }}                                                                                                                   
                                                
FIELD ->                                        
    f=?ident? w1=?w? "=" w2=?w? e=EXPR           {{ (Map.valuename (c f))^(Map.w w1)^"="^(Map.w w2)^e }}                                                                     


(* 6.8 Type and exception definitions *)

TYPEDEFINITION -> "type" w1=?w? s2=TYPEDEF      {{ "\\textsf{type}"^(Map.w w1)^s2 }}                      

TYPEDEF -> TYPECONSTRNAME ?w? TYPEINFORMATION 
      {{ x1^(Map.w x2)^x3 }}                                  
  | TYPECONSTRNAME ?w? TYPEPARAMS ?w? TYPEINFORMATION 
      {{ x1^(Map.w x2)^(x3)^(Map.w x4)^x5 }} 
      (* FIXME what about params? may cause problems because hol lists params in order they occur in defn :( *)                                 
   
TYPEPARAMS -> TYPEPARAM {{ x1 }}
  | TYPEPARAM ?w? TYPEPARAMS              {{ x1^(Map.w x2)^x3 }}

OCAMLTYPEPARAMS -> TYPEPARAM {{ x1 }}
  | "(" ?w? TYPEPARAMSA ?w? ")"           {{ "("^(c x2)^x3^(c x4)^")" }}

TYPEPARAMSA -> TYPEPARAM                  {{ x1 }}
  | TYPEPARAM ?w? "," ?w? TYPEPARAMSA     {{ x1^(Map.w x2)^(c x3)^(Map.w x4)^x5 }}

TYPEPARAM -> "'" ?ident?                  {{ Map.tyvar([x1;x2]|>ss_concat|>c) }}
                                       
TYPECONSTRNAME -> ?ident?                 {{ Map._TYPECONSTRNAME (c x1) }}
                                          
TYPEINFORMATION -> TYPEEQUATION           {{ x1 }}                                                    
  | TYPEREPRESENTATION                    {{ x1 }}                                                    

TYPEEQUATION -> "=" ?w? TYPEXPR           {{ "="^(Map.w x2)^x3 }}

TYPEREPRESENTATION -> "=" ?w? CONSTRDECLS {{ "="^(Map.w x2)^x3 }}                                                    
  | "=" w3=?w? "<|" w1=?w? s2=FIELDDECLS w2=?w? "|>"  {{ "="^(Map.w w3)^"\\langle{}"^(Map.w w1)^s2^(Map.w w2)^"\\rangle{}" }}
                                          
CONSTRDECLS -> CONSTRDECL                 {{ x1 }}                                                    
  | s1=CONSTRDECL w1=?w? "|" w2=?w? s2=CONSTRDECLS    {{ s1^(Map.w w1)^"|"^(Map.w w2)^s2 }}                      
                                          
CONSTRDECL -> CONSTRNAME                  {{ x1 }}                                                    
  | s1=CONSTRNAME w1=?w? "of" w2=?w? s2=TYPEXPR       {{ s1^(Map.w w1)^"\\textsf{of}"^(Map.w w2)^s2 }} 
                                          
CONSTRNAME -> ?_Ident?                     {{ "\\textsf{"^(Map._CONSTRNAME (c x1))^"}" }}                                                     

(* following can end in optional ; *)
FIELDDECLS -> FIELDDECLSA                 {{ x1 }}
  | s1=FIELDDECLSA w1=?w? s2=";"          {{ (s1^(Map.w w1)^" "^(c s2)) }}

FIELDDECLSA -> FIELDDECL                   {{ x1 }}
  | s1=FIELDDECL w1=?w? ";" w2=?w? s2=FIELDDECLSA      {{ s1^(Map.w w1)^";"^(Map.w w2)^s2 }} 

(* FIXME the pattern is we map nonterms to strings; this causes lots of messing about with c and ^ *)

FIELDDECL -> s1=FIELDNAME w1=?w? ":" w2=?w? s2=POLYTYPEXPR {{ s1^(Map.w w1)^":"^(Map.w w2)^s2 }}



>>g>>

let main () = 
  let fname = Sys.argv.(1) in
  let Some txt = read_file_as_string fname in
  let eg = run_parser_string parse_S txt in
  ()

let _ = main ()

(*
Local Variables:
mode: tuareg
End:
*)
