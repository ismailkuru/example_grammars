(* example specification of a grammar file; allows named vars; *)
open P1_lib

let header = until_a ("<<"^"g<<")
let start_of_g = a ("<<"^"g<<")
let end_of_g = a (">>"^"g>>")
let grammar = until_a (">>"^"g>>")
let footer = until_EOF
let ws = parse_RE "[ \n]*"

let nt = parse_RE "[A-Z]+"
let not_dquote = until_a "\""
let not_squote = until_a "'"
let not_q = until_a "?"

let fixme = parse_RE "FIXME"

let act = (a "{{") **> until_a "}}" **> (a "}}") >> (fun (_,(x,_)) -> x)

let c = content
let id = fun x -> x

let var = parse_RE "[a-z][a-z0-9]*"

let eps = a ""

type nt_string = string
type sym = [`NT of nt_string | `TM of string]
type act = [`ACT of string]
type vsym = [`VSYM of string option * sym]
type symsact = [`SYMSACT of vsym list * act]
type rule = [`RULE of nt_string * symsact list]
type g = [`RULES of rule list]
type embedded_g = [`EMBEDG of string * g * string]

<<g<<

S -> ?header? ?start_of_g? ?ws? G ?ws? ?end_of_g? ?footer? 
  {{ fun (h,(_,(_,(g,(_,(_,f)))))) -> `EMBEDG(c h,g,c f) }}

G -> RULES {{ fun x -> `RULES x }}

RULES -> RULE     {{ fun x -> [x] }}
| RULE ?ws? RULES {{ fun (x,(_,y)) -> x::y }}

RULE -> ?nt? ?ws? "->" ?ws? RHS {{ fun (nt,(_,(_,(_,rhs)))) -> `RULE(c nt,rhs) }}

RHS -> SYMSACT              {{ fun x -> [x] }}
| SYMSACT ?ws? "|" ?ws? RHS {{ fun (x,(_,(_,(_,xs)))) -> x::xs }}

SYMSACT -> VSYMS ?ws? ACT {{ fun (x,(_,y)) -> `SYMSACT(x,y) }}

VSYMS -> VSYM     {{ fun x -> [x] }}
| VSYM ?ws? VSYMS {{ fun (x,(_,y)) -> x::y }}

VSYM -> VAROPT SYM {{ fun (x,y) -> `VSYM(x,y) }}

ACT -> ?act? {{ fun x -> `ACT (c x) }}

VAROPT -> ?eps? {{ fun _ -> None }}
| ?var? "=" {{ fun (x,_) -> Some(c x) }}

SYM -> ?nt?             {{ fun x -> `NT (c x) }}
| "?" ?not_q? "?"       {{ fun (_,(x,_)) -> `TM ("?"^(c x)^"?") }}
| '"' ?not_dquote? '"'  {{ fun (_,(x,_)) -> `TM ("\""^(c x)^"\"") }}
| "'" ?not_squote? "'"  {{ fun (_,(x,_)) -> `TM ("'"^(c x)^"'") }}

TYPECHECK -> VSYM {{ fun (x:vsym) -> failwith "FIXME typechecking only" }}
| SYMSACT {{ fun (x:symsact) -> failwith "FIXME typechecking only" }}
| RULE {{ fun (x:rule) -> failwith "FIXME typechecking only" }}
| G {{ fun (x:g) -> failwith "FIXME typechecking only" }}
| S {{ fun (x:embedded_g) -> failwith "FIXME typechecking only" }}
>>g>>

let sym_to_string x = (match x with
    | `NT x -> x
    | `TM x -> x)

let fun_binding_for_act : symsact -> string = (fun (`SYMSACT (xs,`ACT act)) ->
    (* number the xs *)
    let xs = (List.fold_left (fun (n,acc) x -> (n+1,acc@[(n,x)])) (1,[]) xs) |> snd in
    let xs =
      let f1 (n,x) = (match x with 
        | `VSYM(None,sym) -> `VSYM(Some("x"^(string_of_int n)),sym)
        | `VSYM(Some x,sym) -> `VSYM(Some x, sym))
      in
      List.map f1 xs
    in
    let vsym_to_var (`VSYM(Some x,sym)) = x in
    (* left assoc List.fold_left (fun acc x -> String.concat "" ["(";acc;",";(x |> vsym_to_var);")"]) (List.hd xs |> vsym_to_var) (List.tl xs) *)
    let rec f1 xs = (match xs with
        | [vsym] -> (vsym |> vsym_to_var)
        | x::xs -> (String.concat "" ["(";(x |> vsym_to_var);",";f1 xs;")"]))
    in
    f1 xs)

(*
let _ = fun_binding_for_act (`SYMSACT ([`VSYM(None,`NT "E");`VSYM(Some "v",`NT "E");`VSYM(None,`NT "E")],`ACT "act"))

*)

let vsym_to_string (`VSYM (so,sym)) = String.concat "" [
    so |> (fun x -> match x with | None -> "" | Some x -> x^"=");
    sym |> sym_to_string]

let symsact_to_string x = match x with | (`SYMSACT (xs,`ACT act)) -> String.concat "" [
    (xs |> List.map vsym_to_string |> String.concat " ");
    " {{ fun ";fun_binding_for_act x; " -> "; act;"}}"]
      
let rule_to_string (`RULE (nt,xs)) = String.concat "" [
    nt; " -> "; xs |> List.map symsact_to_string |> String.concat "\n | "]

let g_to_string (`RULES xs) = (xs |> List.map rule_to_string |> String.concat "\n")

let embedg_to_string (`EMBEDG(h,g,f)) = String.concat "\n" [
    h ^"<<"^"g<<";
    (g |> g_to_string);
    ">>"^"g>>"^f]

let main () = 
  let fname = Sys.argv.(1) in
  let Some txt = read_file_as_string fname in
  let eg = run_parser_string parse_S txt in
  let _ = eg |> List.map fst |> List.map embedg_to_string |> List.map print_string in
  ()

let _ = main ()

(*
Local Variables:
mode: tuareg
End:
*)
