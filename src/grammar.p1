(* example specification of a grammar file; allows named vars; parse a
   .p1x (with named vars) embedded grammar and output a .p1 embedded
   grammar; also, if there are multiple action clauses, then output
   each to a file: if the act is {bbb{ ... }} then output to xxxbbb.p1
   where xxx is the name of the original file *)
open P1_lib

let c = content

let header = until_a ("<<"^"g<<")
let start_of_g = a ("<<"^"g<<")
let end_of_g = a (">>"^"g>>")
let grammar = until_a (">>"^"g>>")
let footer = until_EOF
let ws = parse_RE "[ \n]*"

let nt = parse_RE "[A-Z]+"
let not_dquote = until_a "\""
let not_squote = until_a "'"
let not_q = until_a "?"

let fixme = parse_RE "FIXME"

let open_act = ((a "{") **> (until_a "{") **> (a "{")) >> (fun (_,(tag,_)) -> (c tag))

let act = (open_act **> until_a "}}" **> (a "}}")) >> (fun (tag,(x,_)) -> `ACT(tag,c x))

let id = fun x -> x

let var = parse_RE "[a-z][a-z0-9]*"

let eps = a ""

type nt_string = string
type sym = [`NT of nt_string | `TM of string]
type act = [`ACT of string * string]
type vsym = [`VSYM of string option * sym]
type symsact = [`SYMSACTS of vsym list * act]
type symsacts = [`SYMSACTS of vsym list * act list]
type rule = [`RULE of nt_string * symsacts list]
type g = [`RULES of rule list]
type embedded_g = [`EMBEDG of string * g * string]

<<g<<

S -> ?header? ?start_of_g? ?ws? G ?ws? ?end_of_g? ?footer? 
  {{ fun (h,(_,(_,(g,(_,(_,f)))))) -> `EMBEDG(c h,g,c f) }}

G -> RULES {{ fun x -> `RULES x }}

RULES -> RULE     {{ fun x -> [x] }}
| RULE ?ws? RULES {{ fun (x,(_,y)) -> x::y }}

RULE -> ?nt? ?ws? "->" ?ws? RHS {{ fun (nt,(_,(_,(_,rhs)))) -> `RULE(c nt,rhs) }}

RHS -> SYMSACTS              {{ fun x -> [x] }}
| SYMSACTS ?ws? "|" ?ws? RHS {{ fun (x,(_,(_,(_,xs)))) -> x::xs }}

SYMSACTS -> VSYMS ?ws? ACTS {{ fun (x,(_,y)) -> `SYMSACTS(x,y) }}

VSYMS -> VSYM     {{ fun x -> [x] }}
| VSYM ?ws? VSYMS {{ fun (x,(_,y)) -> x::y }}

VSYM -> VAROPT SYM {{ fun (x,y) -> `VSYM(x,y) }}

ACTS -> ACT     {{ fun x -> [x] }}
| ACT ?ws? ACTS {{ fun (x,(_,y)) -> x::y }}

ACT -> ?act? {{ id }}

VAROPT -> ?eps? {{ fun _ -> None }}
| ?var? "=" {{ fun (x,_) -> Some(c x) }}

SYM -> ?nt?             {{ fun x -> `NT (c x) }}
| "?" ?not_q? "?"       {{ fun (_,(x,_)) -> `TM ("?"^(c x)^"?") }}
| '"' ?not_dquote? '"'  {{ fun (_,(x,_)) -> `TM ("\""^(c x)^"\"") }}
| "'" ?not_squote? "'"  {{ fun (_,(x,_)) -> `TM ("'"^(c x)^"'") }}

TYPECHECK -> VSYM {{ fun (x:vsym) -> failwith "FIXME typechecking only" }}
| SYMSACTS {{ fun (x:symsacts) -> failwith "FIXME typechecking only" }}
| RULE {{ fun (x:rule) -> failwith "FIXME typechecking only" }}
| G {{ fun (x:g) -> failwith "FIXME typechecking only" }}
| S {{ fun (x:embedded_g) -> failwith "FIXME typechecking only" }}
>>g>>

let sym_to_string x = (match x with
    | `NT x -> x
    | `TM x -> x)


type 'a symspair = [ `SYMSPAIR of vsym list * 'a]

let fun_binding_for_act : 'a symspair -> string = (fun (`SYMSPAIR (xs,_)) ->
    (* number the xs *)
    let xs = (List.fold_left (fun (n,acc) x -> (n+1,acc@[(n,x)])) (1,[]) xs) |> snd in
    let xs =
      let f1 (n,x) = (match x with 
        | `VSYM(None,sym) -> `VSYM(Some("x"^(string_of_int n)),sym)
        | `VSYM(Some x,sym) -> `VSYM(Some x, sym))
      in
      List.map f1 xs
    in
    let vsym_to_var (`VSYM(Some x,sym)) = x in
    (* left assoc List.fold_left (fun acc x -> String.concat "" ["(";acc;",";(x |> vsym_to_var);")"]) (List.hd xs |> vsym_to_var) (List.tl xs) *)
    let rec f1 xs = (match xs with
        | [vsym] -> (vsym |> vsym_to_var)
        | x::xs -> (String.concat "" ["(";(x |> vsym_to_var);",";f1 xs;")"]))
    in
    f1 xs)

(*
let _ = fun_binding_for_act (`SYMSACT ([`VSYM(None,`NT "E");`VSYM(Some "v",`NT "E");`VSYM(None,`NT "E")],`ACT "act"))

*)

let vsym_to_string (`VSYM (so,sym)) = String.concat "" [
    so |> (fun x -> match x with | None -> "" | Some x -> x^"=");
    sym |> sym_to_string]

let symsact_to_string x = match x with | (`SYMSACT (xs,`ACT (tag,act))) -> 
  (* remove var bindings because we are transforming into a grammar without extensions *)
  let ys = List.map (fun (`VSYM (so,sym)) -> `VSYM(None,sym)) xs in
  String.concat "" [
    (ys |> List.map vsym_to_string |> String.concat " ");
    " {{ fun ";(`SYMSPAIR(xs,()) |> fun_binding_for_act); " -> "; act;"}}"]

let symsacts_to_string : symsacts -> string = fun x -> match x with | (`SYMSACTS (xs,acts)) -> 
  let act = (match acts with | act::_ -> act | _ -> failwith "symsacts_to_string") in
  (`SYMSACT(xs,act) |> symsact_to_string)
  
      
let rule_to_string : rule -> string = fun (`RULE (nt,xs)) -> String.concat "" [
    nt; " -> "; xs |> List.map symsacts_to_string |> String.concat "\n | "]

let g_to_string (`RULES xs) = (xs |> List.map rule_to_string |> String.concat "\n")

let embedg_to_string (`EMBEDG(h,g,f)) = String.concat "\n" [
    h ^"<<"^"g<<";
    (g |> g_to_string);
    ">>"^"g>>"^f]

let main () = 
  let fname = Sys.argv.(1) in
  let Some txt = read_file_as_string fname in
  let eg = run_parser_string parse_S txt in
  let _ = eg |> List.map fst |> List.map embedg_to_string |> List.map print_string in
  ()

let _ = main ()

(*
Local Variables:
mode: tuareg
End:
*)
